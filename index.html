<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content-Defined Chunking & Rolling Hash (Leading Zeros) Visualizer</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --text-color: #333;
            --highlight-color: #3498db;
            --window-border: #e74c3c;
            --boundary-color: #27ae60;
            --chunk-bg-1: #ecf0f1;
            --chunk-bg-2: #d5dbdb;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 { color: var(--text-color); }

        .container {
            background: #fff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 950px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        input[type="text"], input[type="number"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: monospace;
            font-size: 1rem;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }

        button:active { transform: scale(0.98); }
        #step-btn { background-color: var(--highlight-color); color: white; }
        #play-btn { background-color: var(--boundary-color); color: white; }
        #reset-btn { background-color: #95a5a6; color: white; }

        .visualization { margin-bottom: 25px; }

        .data-stream-container {
            position: relative;
            font-family: monospace;
            font-size: 1.3rem;
            white-space: nowrap;
            overflow-x: auto;
            padding: 15px 15px 25px 15px; /* More bottom padding for scrollbar */
            background: #fafafa;
            border-radius: 6px;
            border: 2px solid #eee;
        }

        .char {
            display: inline-block;
            width: 30px;
            text-align: center;
            padding: 5px 0;
        }

        .window {
            position: absolute;
            top: 10px;
            height: calc(100% - 40px); /* Adjust for padding */
            border: 3px solid var(--window-border);
            border-radius: 4px;
            box-sizing: border-box;
            background-color: rgba(231, 76, 60, 0.1);
            transition: left 0.2s ease-in-out;
        }

        .boundary-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background-color: var(--boundary-color);
            z-index: 10;
        }

        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .info-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid var(--highlight-color);
        }

        .info-box h3 { margin: 0 0 10px 0; font-size: 1.1rem; }
        .hash-value { font-family: monospace; font-size: 1.2rem; color: var(--highlight-color); }
        .highlight { color: var(--window-border); font-weight: bold; }
        
        #hash-binary {
            display: inline-block;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 4px 8px;
            border-radius: 4px;
            margin-top: 5px;
            word-break: break-all;
        }

        .chunks-display {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .chunk {
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 1rem;
            border: 2px solid #ccc;
            max-width: 100%;
            overflow-wrap: break-word;
        }
        .chunk:nth-child(odd) { background-color: var(--chunk-bg-1); }
        .chunk:nth-child(even) { background-color: var(--chunk-bg-2); }

        .explanation {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <h1>Content-Defined Chunking & Rolling Hash</h1>

    <div class="container">
        <div class="controls">
            <div class="control-group" style="grid-column: 1 / -1;">
                <label for="data-input">Data Stream (Text):</label>
                <input type="text" id="data-input" value="content defined chunking uses data patterns to cut">
            </div>
            <div class="control-group">
                <label for="window-size">Window Size:</label>
                <input type="number" id="window-size" value="8" min="2" max="30">
            </div>
            <div class="control-group">
                <label for="target-zeros" title="Probability of boundary is 1/(2^n)">Target Leading Zeros (n):</label>
                <input type="number" id="target-zeros" value="3" min="1" max="25">
            </div>
             <div class="control-group">
                <label title="Expected average chunk size = 2^n">Avg. Chunk Size (2‚Åø):</label>
                <input type="text" id="avg-size" value="8" readonly style="background: #eee; color: #666; cursor: not-allowed;">
            </div>
            <div class="buttons" style="grid-column: 1 / -1; justify-content: center;">
                <button id="step-btn">Step ></button>
                <button id="play-btn">Play >></button>
                <button id="reset-btn">Reset</button>
            </div>
        </div>

        <div class="visualization">
            <div class="data-stream-container" id="data-stream">
                <div class="window" id="sliding-window"></div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-box">
                <h3>Rolling Hash Info</h3>
                <p>Current Window: <span id="current-window-text" class="highlight"></span></p>
                <p>Current Hash (Dec): <span id="current-hash" class="hash-value">0</span></p>
            </div>
            <div class="info-box" style="border-left-color: var(--boundary-color);">
                <h3>Chunking Status</h3>
                <p>Boundary Found? <span id="boundary-status" style="font-weight: bold; color: #e74c3c;">No</span></p>
                <p>Hash (32-bit Binary):<br> <span id="hash-binary" style="font-family: monospace; font-size: 0.85rem;"></span></p>
                <p>Leading Zeros: <span id="zeros-count" class="hash-value" style="color: var(--boundary-color);"></span> (Target: <span id="lbl-target-zeros"></span>)</p>
                <p style="font-size: 0.8rem; margin-top: 5px;">Condition: <code>Leading Zeros >= Target</code></p>
            </div>
        </div>

        <div>
            <h3>Generated Chunks:</h3>
            <div class="chunks-display" id="chunks-container">
                </div>
        </div>
    </div>
    
    <div class="container" style="margin-top: 20px;">
        <div class="explanation">
            <h3>How it Works (Leading Zeros Method):</h3>
            <ol>
                <li>A <strong>sliding window</strong> moves over the data. At each step, a <strong>rolling hash</strong> is calculated for the window's content.</li>
                <li>The tool converts the hash value into its 32-bit <strong>binary representation</strong>.</li>
                <li>It counts the number of **leading zeros** in this binary string.</li>
                <li>If the <code>Count of Leading Zeros</code> is greater than or equal to your chosen <code>Target Leading Zeros (n)</code>, a **chunk boundary** is created.</li>
                <li>This is a probabilistic method. Searching for $n$ leading zeros means the probability of finding a boundary at any specific point is $1/2^n$. This results in an expected average chunk size of $2^n$ bytes.</li>
            </ol>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const config = {
            base: 257, // Base for the polynomial hash (a prime number > 256 usually)
            prime: 1000000007 // A large prime to fit within 32-bit signed integer range for accurate bitwise ops
        };

        let state = {
            data: '',
            windowSize: 0,
            targetLeadingZeros: 0,
            currentIndex: 0,
            currentHash: 0,
            lastBoundaryIndex: 0,
            chunks: [],
            boundaries: [],
            isPlaying: false,
            playInterval: null,
            windowPower: 1 // base^(windowSize-1) % prime
        };

        // --- DOM Elements ---
        const elements = {
            dataInput: document.getElementById('data-input'),
            windowSizeInput: document.getElementById('window-size'),
            targetZerosInput: document.getElementById('target-zeros'),
            avgSizeInput: document.getElementById('avg-size'),
            stepBtn: document.getElementById('step-btn'),
            playBtn: document.getElementById('play-btn'),
            resetBtn: document.getElementById('reset-btn'),
            dataStream: document.getElementById('data-stream'),
            slidingWindow: document.getElementById('sliding-window'),
            currentWindowText: document.getElementById('current-window-text'),
            currentHash: document.getElementById('current-hash'),
            hashBinary: document.getElementById('hash-binary'),
            zerosCount: document.getElementById('zeros-count'),
            boundaryStatus: document.getElementById('boundary-status'),
            lblTargetZeros: document.getElementById('lbl-target-zeros'),
            chunksContainer: document.getElementById('chunks-container')
        };

        // --- Rolling Hash Implementation ---
        // Uses a polynomial rolling hash: H = (c1*b^(k-1) + c2*b^(k-2) + ... + ck*b^0) % prime
        
        function initHash(text_window) {
            let h = 0;
            for (let i = 0; i < text_window.length; i++) {
                h = (h * config.base + text_window.charCodeAt(i)) % config.prime;
            }
            return h;
        }

        function rollHash(oldHash, charOut, charIn) {
            // H_new = ((H_old - charOut * base^(k-1)) * base + charIn) % prime
            let h = oldHash;
            // Add config.prime before modulo to handle potential negative result after subtraction
            h = (h - (charOut.charCodeAt(0) * state.windowPower) % config.prime + config.prime) % config.prime;
            h = (h * config.base) % config.prime; // Shift left
            h = (h + charIn.charCodeAt(0)) % config.prime; // Add incoming char
            return h;
        }

        // --- Visualization Logic ---

        function initialize() {
            stopPlay();
            state.data = elements.dataInput.value;
            state.windowSize = parseInt(elements.windowSizeInput.value);
            state.targetLeadingZeros = parseInt(elements.targetZerosInput.value);
            state.currentIndex = 0;
            state.lastBoundaryIndex = 0;
            state.chunks = [];
            // Remove old markers
            state.boundaries.forEach(marker => marker.remove());
            state.boundaries = [];
            
            // Pre-calculate base^(windowSize-1) % prime
            state.windowPower = 1;
            for(let i=0; i < state.windowSize - 1; i++) {
                state.windowPower = (state.windowPower * config.base) % config.prime;
            }

            // Render initial data stream
            elements.dataStream.innerHTML = '<div class="window" id="sliding-window"></div>';
            for (let char of state.data) {
                const charSpan = document.createElement('span');
                charSpan.className = 'char';
                charSpan.textContent = char === ' ' ? '\u00A0' : char; // Handle spaces visually
                elements.dataStream.appendChild(charSpan);
            }
            elements.slidingWindow = document.getElementById('sliding-window'); // Re-acquire ref

            // Update labels and initial UI
            elements.lblTargetZeros.textContent = state.targetLeadingZeros;
            elements.avgSizeInput.value = Math.pow(2, state.targetLeadingZeros);
            elements.chunksContainer.innerHTML = '';
            updateUI();

            if (state.data.length >= state.windowSize) {
                state.currentHash = initHash(state.data.substring(0, state.windowSize));
                updateVisualization();
            } else {
                 // Handle short data gracefully
                 elements.currentWindowText.textContent = "Data too short";
                 elements.stepBtn.disabled = true;
                 elements.playBtn.disabled = true;
            }
        }

        function updateUI() {
            elements.stepBtn.disabled = state.currentIndex > state.data.length - state.windowSize;
            elements.playBtn.disabled = elements.stepBtn.disabled;
            elements.playBtn.textContent = state.isPlaying ? "Pause ||" : "Play >>";
        }

        function updateVisualization() {
            const windowEndIndex = state.currentIndex + state.windowSize;
            const currentWindowStr = state.data.substring(state.currentIndex, windowEndIndex);
            
            // 1. Move Window (30px is char width + padding defined in CSS)
            const charWidth = 30; 
            elements.slidingWindow.style.left = `${state.currentIndex * charWidth + 15}px`;
            elements.slidingWindow.style.width = `${state.windowSize * charWidth}px`;

            // 2. Update Hash Info
            elements.currentWindowText.textContent = `"${currentWindowStr}"`;
            elements.currentHash.textContent = state.currentHash;

            // --- NEW LOGIC: Leading Zeros ---
            // Count leading zeros in 32-bit integer representation
            const leadingZeros = Math.clz32(state.currentHash);
            
            // Create 32-bit padded binary string for display
            // We use >>> 0 to coerce to an unsigned 32-bit integer before toString(2)
            // to handle potential edge cases, although our prime keeps it positive.
            const binaryStr = (state.currentHash >>> 0).toString(2).padStart(32, '0');
            
            // Visually highlight the leading zeros
            let formattedBinary = binaryStr;
            if (leadingZeros > 0) {
                 formattedBinary = `<span style="color: var(--boundary-color); font-weight: bold;">${binaryStr.substring(0, leadingZeros)}</span>${binaryStr.substring(leadingZeros)}`;
            }

            elements.hashBinary.innerHTML = formattedBinary;
            elements.zerosCount.textContent = leadingZeros;

            // 3. Check Boundary Condition
            const isBoundary = leadingZeros >= state.targetLeadingZeros;

            if (isBoundary) {
                elements.boundaryStatus.textContent = `YES! (${leadingZeros} >= ${state.targetLeadingZeros})`;
                elements.boundaryStatus.style.color = "var(--boundary-color)";
                
                // Place visual marker
                const marker = document.createElement('div');
                marker.className = 'boundary-marker';
                // Position at the end of the current window
                marker.style.left = `${windowEndIndex * charWidth + 15}px`;
                elements.dataStream.appendChild(marker);
                state.boundaries.push(marker);

                // Create Chunk
                const newChunk = state.data.substring(state.lastBoundaryIndex, windowEndIndex);
                state.chunks.push(newChunk);
                state.lastBoundaryIndex = windowEndIndex;

                renderChunks();
            } else {
                elements.boundaryStatus.textContent = "No";
                elements.boundaryStatus.style.color = "#e74c3c";
            }

            updateUI();
        }

        function renderChunks() {
            elements.chunksContainer.innerHTML = '';
            state.chunks.forEach(chunk => {
                const chunkDiv = document.createElement('div');
                chunkDiv.className = 'chunk';
                chunkDiv.textContent = chunk;
                elements.chunksContainer.appendChild(chunkDiv);
            });
        }

        function step() {
            if (state.currentIndex < state.data.length - state.windowSize) {
                const charOut = state.data[state.currentIndex];
                const charIn = state.data[state.currentIndex + state.windowSize];
                
                // Roll the hash
                state.currentHash = rollHash(state.currentHash, charOut, charIn);
                
                state.currentIndex++;
                updateVisualization();
            } else {
                finalize();
            }
        }

        function finalize() {
             // End of data reached
             stopPlay();
             if (state.lastBoundaryIndex < state.data.length) {
                 // Add the final remaining piece of data as a chunk
                 const finalChunk = state.data.substring(state.lastBoundaryIndex);
                 state.chunks.push(finalChunk);
                 renderChunks();
             }
             updateUI();
        }

        function togglePlay() {
            if (state.isPlaying) {
                stopPlay();
            } else {
                state.isPlaying = true;
                elements.playBtn.textContent = "Pause ||";
                state.playInterval = setInterval(() => {
                    if (state.currentIndex < state.data.length - state.windowSize) {
                        step();
                    } else {
                        finalize();
                    }
                }, 400); // Animation speed (ms)
            }
        }

        function stopPlay() {
            state.isPlaying = false;
            clearInterval(state.playInterval);
            updateUI();
        }

        // --- Event Listeners ---
        elements.resetBtn.addEventListener('click', initialize);
        elements.stepBtn.addEventListener('click', step);
        elements.playBtn.addEventListener('click', togglePlay);
        
        // Live update for "Avg. Chunk Size" field
        elements.targetZerosInput.addEventListener('input', (e) => {
            const n = parseInt(e.target.value);
            if (!isNaN(n)) {
                 elements.avgSizeInput.value = Math.pow(2, n);
            }
        });

        // Initialize on load
        initialize();

    </script>
</body>
</html>
